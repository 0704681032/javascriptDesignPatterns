<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>解释器模式</title>
</head>
<body>
    
<script>
/**
 * 解释器模式
 *
 * 定义：
 * 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
 *
 * 解析器
 * 指的是把描述客户端调用要求的表达式，经过解析，形成一个抽象语法树的程序。
 *
 * 解释器
 * 指的是解释抽象语法树，并执行每个节点对应的功能的程序。
 *
 * 要使用解释器模式，一个重要的前提就是要定义一套语法规则，也成为文法。不管这套文法的规则是简单还是复杂，必须要有这些规则，因为解释器模式就是按照这些规则来进行解析并执行相应的功能的。
 */

(function(){
    // 示例代码
    
    // 终结符表达式
    var TerminalExpression = function(){};
    TerminalExpression.prototype = {
        /**
         * 解释的操作
         * @param  {[type]} context [上下文]
         */
        interpret: function(context){
            // 实现与语法规则中的终结符相关联的解释操作
        }
    };

    // 非终结符表达式
    var NonterminalExpression = function(){};
    NonterminalExpression.prototype = {
        interpret: function(context){
            // 实现与语法规则中的非终结符相关联的解释操作
        }
    };

    // 上下文，包含解释器之外的一些全局信息
    var Context = function(){};

    // 使用解释器的客户
    // 主要按照语法规则对特定句子构建抽象语法树
    // 然后调用解释操作
}());

(function(){
    /**
     * 1.为表达式设计简单的文法
     *
     * 为了通用，用root表示根元素，abc等来代表元素，一个简单的xml如下：
     * <?xml version="1.0" encoding="UTF-8">
     * <root id="rootId">
     *     <a>
     *         <b>
     *             <c name="testC">12345</c>
     *             <d id="1">d1</d>
     *             <d id="2">d2</d>
     *             <d id="3">d3</d>
     *             <d id="4">d4</d>
     *         </b>
     *     </a>
     * </root>
     *
     * 约定表达式的文法如下：
     * 1.获取单个元素的值：从根元素开始，一直到想要获取取值的元素，元素中间用“/”分隔，根元素前不加“/”。比如，表达式“root/a/b/c”就表示获取根元素下，a元素下，b元素下，c元素的值。
     * 2.获取单个元素的属性的值：当然是多个，要获取值的属性一定是表达式的最后一个元素的属性，在最后一个元素后面添加“.”然后再加上属性的名称。比如，表达式“root/a/b/c.name”就表示获取根元素下，a元素下，b元素下，c元素的name属性的值。
     * 3.获取相同元素名称的值，当然是多个，要获取值的元素一定是表达式的最后一个元素，在最后一个元素后面添加“$”。比如，表达式“root/a/b/d$”就表示获取根元素下，a元素下，b元素下的多个d元素的值的集合。
     * 4.获取相同元素名称的属性的值，当然也是多个：要获取属性值的元素一定是表达式的最后一个元素，在最后一个元素后面添加"$"。比如，表达式“root/a/b/d$.id$”就表示获取根元素下，a元素下，b元素下的多个d元素的id属性的值的集合。
     */
}());

</script>
</body>
</html>
