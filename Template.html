<!DOCTYPE HTML>
<html lang="en-US">
<head>
    <meta charset="utf-8">
    <title></title>
</head>
<body>
<img src="Template.jpg" alt=""/>
<script>
    function extend(subclass, superclass) {
        var F = function () {
        };
        F.prototype = superclass.prototype;
        subclass.prototype = new F();
        subclass.prototype.constructor = subclass;
        subclass.super = superclass.prototype;


        if (superclass.prototype.constructor === Object.prototype.constructor) {
            superclass.prototype.constructor = superclass;
        }
    }

    function rewrite(targetObj, obj, deep) {
        if (Object.prototype.toString.call(obj) !== '[object Object]') {
            return;
        }
        for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
                if (deep === true) {
                    targetObj[i] = targetObj[i] || {};
                    rewrite(targetObj[i], obj[i], deep);
                } else {
                    targetObj[i] = obj[i];
                }
            }
        }
    }
</script>

<script>
    /**
     * 模板模式
     *
     * 模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。
     *
     * 本质
     * 固定算法骨架
     *
     * 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
     */

    // 咖啡因饮料是一个抽象类
    var CaffeineBeverage = function () {
    };
    CaffeineBeverage.prototype = {
        /*---模板方法 ----*/
        /**
         * 它的用作一个算法的模板，在这个例子中，算法是用来制作咖啡因饮料的,
         * 在这个模板中，算法内的每一个步骤都被一个方法代表了
         */
        prepareRecipe: function () {
            this.boilWater();
            this.brew();
            this.pourInCup();
            this.addConditions();
        },
        /*----------------*/
        /* 因为咖啡和茶处理这些方法的做法不同，所以这两个方法必须被声明为抽象 */
        brew: function () {
            throw new Error('abstract brew method should be written.');
        },
        addConditions: function () {
            throw new Error('abstract addConditions method should be written.');
        },
        /* ------------------------------- */
        boilWater: function () {
            console.log('boiling water');
        },
        pourInCup: function () {
            console.log('pouring into cup');
        }
    };

    var Tea = function () {
    };
    extend(Tea, CaffeineBeverage);
    rewrite(Tea.prototype, {
        brew: function () {
            console.log('steeping the tea.');
        },
        addConditions: function () {
            console.log('adding lemon');
        }
    });

    var Coffee = function () {
    };
    extend(Coffee, CaffeineBeverage);
    rewrite(Coffee.prototype, {
        brew: function () {
            console.log('Dripping Coffee through filter');
        },
        addConditions: function () {
            console.log('adding Sugar and Milk');
        }
    });

    var myTea = new Tea();
    myTea.prepareRecipe();

    /*
     由CaffeineBeverage类主导一切，它拥有算法，而且保护这个算法。对子类来说，CaffeineBeverage类deep存在，可以将代码的复用最大化。算法只存在于一个地方，所以容易修改。这个模板方法提供了一个框架，可以让其他的咖啡因饮料插进去，新的咖啡因饮料只需要实现自己的方法就可以了。CaffeeineBeverage类专注在算法本身，而由子类提供完整的实现。
     */

    /*
     对模板方法进行挂钩

     钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。
     */

    // 高层组件，只有在需要子类实现某个方法时，方调用子类。
    var CaffeineBeverageWithHook = function () {
    };
    CaffeineBeverageWithHook.prototype = {
        prepareRecipe: function () {
            this.boilWater();
            this.brew();
            this.pourInCup();
            /*---------- 钩子 ----------*/
            if (this.customerWantsCondiments()) {
                this.addCondiments();
            }
            /*---------------------------*/
        },
        brew: function () {
            throw new Error('brew method should be rewritten.');
        },
        addCondiments: function () {
            throw new Error('addCondiments method should be written.');
        },
        boilWater: function () {
            console.log('Boiling water');
        },
        pourInCup: function () {
            console.log('pourng into cup');
        },
        /*------- 钩子方法 ------*/
        customerWantsCondiments: function () {
            return true;
        }
        /*----------------------*/
    };

    var CoffeeWithHook = function () {
    };
    extend(CoffeeWithHook, CaffeineBeverageWithHook);
    rewrite(CoffeeWithHook.prototype, {
        brew: function () {
            console.log('Dripping coffee through filter');
        },
        customerWantsCondiments: function () {
            var answer = this.getUSerInput();

            return answer === true;
        },
        getUSerInput: function () {
            return confirm('Would you like milk and sugar with your coffee (y/n)?');
        },
        addCondiments: function () {
            console.log('adding sugar and milk');
        }
    });

    var coffeeHook = new CoffeeWithHook();
    coffeeHook.prepareRecipe();

    /*
     好莱坞原则

     别调用我们，我们会调用你。

     好莱坞原则可以给我们一种防止“依赖腐败”的方法。当高层组件依赖低层组件，而低层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依赖低层组件时，依赖腐败就发生了。在这种情况下，没有人可以轻易地搞懂系统是如何设计的。
     在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，高层组建对待低层组件的方式是“别调用我们，我们会调用你”。
     */

    /*
     抽象类不一定包含抽象方法；有抽象方法的类一定是抽象类。
     “既要约束子类的行为，又要为子类提供公共功能”的时候使用抽象类。
     */

    var Duck = function (name, weight) {
        this.name = name;
        this.weight = weight;
    };
    Duck.prototype = {
        toString: function () {
            return name + ' weighs ' + this.weight;
        }
    };

    var ducks = [
        new Duck('A', 8),
        new Duck('B', 2),
        new Duck('C', 7),
        new Duck('D', 2),
        new Duck('E', 10),
        new Duck('E', 2)
    ];
    console.log('before');
    display(ducks);

    /*---------- 内置对象的模板方法 --------*/
    ducks.sort(function (obj1, obj2) {
        return obj1.weight - obj2.weight;
    });
    /*-------------------------------------*/

    console.log('after');
    display(ducks);

    function display(arr) {
        for (var i = 0, len = arr.length; i < len; i++) {
            console.log(arr[i] + '');
        }
    }

    /*
     优点

     实现代码复用。

     缺点

     算法骨架不容易升级
     */

    /*
     何时使用

     1.需要固定定义算法骨架，实现了一个算法的不变的部分，并把可变的行为留给子类来实现的情况。
     2.各个子类中具有公共行为，应该抽取出来，集中在一个公共类去实现，从而避免代码重复。
     3.需要控制子类扩展的情况。模板方法模式会在特定的点来调用子类的方法，这样只允许在这些点进行扩展。
     */
    
} 


// http://blog.csdn.net/dead_of_winter/article/details/2159420
    
function parent(prototype){
    return function(){
        for(var p in o) this[p]=prototype[p];
        // 模板方法
        this.show=function(){
             alert("show");
        }
};

// 广度优先搜索的例子

function BreadthFirstSearch(extend,beam,finish)
{
    return function(){
        this.finish=finish;
        this.extend=extend;
        this.beam=beam; 
        this.search=function(){
            
            var queue=[this];
            while(queue.length)
            {
                var current=queue.shift();
                if(!current.beam()){
                    var extended=current.extend();
                    for(var i=0;i<extended.length;i++)
                    {
                        if(extended[i].finish())return extended[i];
                        queue.push(extended[i]);
                    }
                }        
            }
            return null;
        }
    }
}


(function(){
    // 解决八皇后问题的例子的例子

function Queen(n){
    var ret=new Array();
    ret.size=n;                                //皇后问题的规模
    ret.depth=0;                                //搜索的深度
    ret.pos=0;                                //新皇后的水平位置
    for(var y=0;y<n;y++)
    {
        ret.push([]);
        for(var x=0;x<n;x++)
            ret[ret.length-1].push(0);
    }
    function objectPrototypeClone()
    {
        var tmp=function(){};
        tmp.prototype=this;
        return new tmp;
    }
    ret.clone=function(){
        var r=objectPrototypeClone.call(this);
        for(var i=0;i<n;i++)
        {
            r[i]=objectPrototypeClone.call(this[i])
        }
        return r;
    }
    ret.toString=function(){
        var str="";
        for(var y=0;y<n;y++)
        {
            for(var x=0;x<n;x++)
                str+=this[y][x]==0?"○":"★";
            str+=" ";
        }
        return str;
    }
    return ret;
}

function extendQueen()
{
    var ret=new Array();
    if(this.depth==this.size)return ret;
    for(var i=0;i<this.size;i++)
    {
        var current=this.clone();
        //alert(current.depth);
        current[current.depth][i]=1;
        current.pos=i;
        current.depth++;
        ret.push(current);
    }
    return ret;
}
function beamQueen()
{
    var x,y;
    if(this.depth==0)return false;
    if(this.depth==this.size)return true;
    x=this.pos;y=this.depth-1;
    while(--x>=0&&--y>=0)
        if(this[y][x]!=0)return true;

    x=this.pos;y=this.depth-1;
    while(--y>=0)
        if(this[y][x]!=0)return true;

    x=this.pos;y=this.depth-1;
    while(--y>=0&&++x<this.size)
    {
        if(this[y][x]!=0)return true;
    }
    return false;
}

function finishQueen(){

    if(this.depth<this.size)return false;
    x=this.pos;y=this.depth-1;
    while(--x>=0&&--y>=0)
        if(this[y][x]!=0)return false;

    x=this.pos;y=this.depth-1;
    while(--y>=0)
        if(this[y][x]!=0)return false;

    x=this.pos;y=this.depth-1;
    while(--y>=0&&++x<this.size)
    {
        if(this[y][x]!=0)return false;
    }

    document.write(++count+". "+this);
    return false;
}
function BreadthFirstSearch(extend,beam,finish)
{
    return function(){
        this.finish=finish;
        this.extend=extend;
        this.beam=beam; 
        this.search=function(){
            
            var queue=[this];
            while(queue.length)
            {
                var current=queue.shift();
                if(!current.beam()){
                    var extended=current.extend();
                    for(var i=0;i<extended.length;i++)
                    {
                        if(extended[i].finish())return extended[i];
                        queue.push(extended[i]);
                    }
                }        
            }
            return null;
        }
    }
}
function BFSQueen(n)
{
    var ret=new Queen(n);
    var BFS=new BreadthFirstSearch(extendQueen,beamQueen,finishQueen);
    BFS.apply(ret);
    return ret;
}
var queen=new BFSQueen(8);
var count=0;
queen.search();
}());
</script>
</body>
</html>
